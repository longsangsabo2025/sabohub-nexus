import { useState, useEffect, useRef } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useNavigate, useLocation } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import {
  Bot,
  Brain,
  TrendingUp,
  AlertTriangle,
  CheckCircle,
  Send,
  Sparkles,
  Target,
  Users,
  MessageSquare,
  BarChart3,
  Lightbulb,
  Play,
  Settings,
  RefreshCw,
  Zap,
  ListTodo,
  ArrowRight,
} from 'lucide-react';
import { supabase } from '@/lib/supabase';
import { cn } from '@/lib/utils';
import { format } from 'date-fns';
import { vi } from 'date-fns/locale';
import { aiService } from '@/services/aiService';
import type { AIMessage as AIServiceMessage } from '@/services/aiService';

interface AIInsight {
  id: string;
  type: 'opportunity' | 'risk' | 'anomaly' | 'recommendation' | 'prediction';
  priority: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  data: Record<string, any>;
  actions: AIAction[];
  confidence: number;
  createdAt: Date;
  category: string;
}

interface AIAction {
  id: string;
  label: string;
  type: 'create_task' | 'send_alert' | 'approve' | 'schedule_meeting';
  params: Record<string, any>;
}

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  insights?: AIInsight[];
}

interface CompanyMetrics {
  employees: { 
    total: number; 
    active: number; 
    onLeave: number;
    workload?: Record<string, { total: number; completed: number; overdue: number }>;
  };
  tasks: { total: number; completed: number; overdue: number; completionRate: number };
  attendance: { avgRate: number; lateCount: number; absentCount: number };
  financial: { revenue: number; expenses: number; profit: number; trend: 'up' | 'down' | 'neutral' };
  kpi: { achieved: number; total: number; percentage: number };
}

/**
 * CEO AI ASSISTANT - JARVIS for Business
 * 
 * Elon Musk Philosophy:
 * - First principles: What does a CEO actually need? Insights, not raw data.
 * - Automation: AI should handle routine analysis, CEO focuses on decisions.
 * - Speed: Real-time insights, not weekly reports.
 * - Proactive: Predict problems, don't just report them.
 */
export default function CEOAssistant() {
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const location = useLocation();
  const [activeTab, setActiveTab] = useState('assistant');
  const [autoDelegateData, setAutoDelegateData] = useState<{ autoGenerated: string; businessContext: any } | null>(null);
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [inputMessage, setInputMessage] = useState('');
  const [autoAnalysisEnabled, setAutoAnalysisEnabled] = useState(true);
  const [sessionId, setSessionId] = useState<string>(crypto.randomUUID());
  const [isLoadingHistory, setIsLoadingHistory] = useState(true);
  const chatEndRef = useRef<HTMLDivElement>(null);
  
  // Check if coming from auto-delegate redirect
  useEffect(() => {
    if (location.state?.openDelegator) {
      setActiveTab('delegator');
    }
  }, [location.state]);

  // Function to send AI message to Task Delegator
  const handleSendToTaskDelegator = (messageContent: string) => {
    setAutoDelegateData({
      autoGenerated: messageContent,
      businessContext: null,
    });
    setActiveTab('delegator');
  };
  
  // Get AI provider info
  const aiProvider = aiService.getProviderInfo();

  // Fetch real-time company metrics
  const { data: metrics, isLoading: metricsLoading } = useQuery<CompanyMetrics>({
    queryKey: ['ceo-ai-metrics'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data: company } = await supabase
        .from('companies')
        .select('id')
        .eq('owner_id', user.id)
        .single();

      if (!company) throw new Error('Company not found');

      // Parallel queries for all metrics (using REAL data + PHASE 3: FINANCIAL!)
      const [employees, tasks, taskAssignments, attendance, financialData] = await Promise.all([
        supabase.from('employees').select('id, full_name, role, is_active, deleted_at').eq('company_id', company.id),
        supabase.from('tasks').select('id, status, due_date, assigned_to, deleted_at').eq('company_id', company.id),
        supabase.from('tasks').select('assigned_to, status').eq('company_id', company.id).not('assigned_to', 'is', null),
        supabase.from('attendance').select('id, user_id, check_in').eq('company_id', company.id).gte('check_in', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()),
        supabase.from('financial_transactions').select('type, amount, transaction_date').eq('company_id', company.id).gte('transaction_date', new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString()).is('deleted_at', null),
      ]);

      const activeEmployees = employees.data?.filter(e => e.is_active && !e.deleted_at) || [];
      const activeTasks = tasks.data?.filter(t => !t.deleted_at) || [];
      const completedTasks = activeTasks.filter(t => t.status === 'completed');
      const overdueTasks = activeTasks.filter(t => t.status !== 'completed' && t.due_date && new Date(t.due_date) < new Date());
      
      // NEW: Employee workload analysis
      const workloadByEmployee = taskAssignments.data?.reduce((acc, task) => {
        const empId = task.assigned_to;
        if (!empId) return acc;
        if (!acc[empId]) acc[empId] = { total: 0, completed: 0, overdue: 0 };
        acc[empId].total++;
        if (task.status === 'completed') acc[empId].completed++;
        return acc;
      }, {} as Record<string, {total: number, completed: number, overdue: number}>) || {};

      // Attendance calculation (real data!)
      const totalWorkDays = 22; // ~22 working days in a month
      const attendanceRate = attendance.data && activeEmployees.length > 0
        ? Math.round((attendance.data.length / (activeEmployees.length * totalWorkDays)) * 100)
        : 0;

      // PHASE 3: Financial calculations (90 days)
      const transactions = financialData.data || [];
      const revenue = transactions.filter(t => t.type === 'revenue').reduce((sum, t) => sum + Number(t.amount), 0);
      const expenses = transactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + Number(t.amount), 0);
      const profit = revenue - expenses;
      
      // Calculate trend (last 30 days vs previous 30 days)
      const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
      const sixtyDaysAgo = Date.now() - 60 * 24 * 60 * 60 * 1000;
      const recentRevenue = transactions.filter(t => t.type === 'revenue' && new Date(t.transaction_date).getTime() > thirtyDaysAgo).reduce((sum, t) => sum + Number(t.amount), 0);
      const previousRevenue = transactions.filter(t => t.type === 'revenue' && new Date(t.transaction_date).getTime() > sixtyDaysAgo && new Date(t.transaction_date).getTime() <= thirtyDaysAgo).reduce((sum, t) => sum + Number(t.amount), 0);
      const trend = previousRevenue > 0 ? (recentRevenue > previousRevenue ? 'up' : recentRevenue < previousRevenue ? 'down' : 'neutral') : 'neutral';

      return {
        employees: {
          total: employees.data?.length || 0,
          active: activeEmployees.length,
          onLeave: employees.data?.filter(e => !e.is_active && !e.deleted_at).length || 0,
          workload: workloadByEmployee, // NEW: Workload per employee
        },
        tasks: {
          total: activeTasks.length,
          completed: completedTasks.length,
          overdue: overdueTasks.length,
          completionRate: activeTasks.length > 0 ? Math.round((completedTasks.length / activeTasks.length) * 100) : 0,
        },
        attendance: {
          avgRate: attendanceRate, // REAL data!
          lateCount: 0, // TODO: Parse check_in time
          absentCount: Math.max(0, (activeEmployees.length * totalWorkDays) - (attendance.data?.length || 0)),
        },
        financial: {
          revenue: Math.round(revenue), // PHASE 3: REAL financial data!
          expenses: Math.round(expenses),
          profit: Math.round(profit),
          trend: trend as 'up' | 'down' | 'neutral',
        },
        kpi: {
          achieved: 0, // Phase 2: kpi_actuals table
          total: 0,
          percentage: 0,
        },
      };
    },
    refetchInterval: autoAnalysisEnabled ? 60000 : false, // Refresh every minute if auto-analysis enabled
  });

  // AI-generated insights based on metrics + PREDICTIVE ANALYTICS
  const { data: insights, isLoading: insightsLoading } = useQuery<AIInsight[]>({
    queryKey: ['ceo-ai-insights', metrics],
    queryFn: async () => {
      if (!metrics) return [];

      const generatedInsights: AIInsight[] = [];

      // ============================================
      // PHASE 2: PREDICTIVE ANALYTICS
      // Elon Principle: Predict problems BEFORE they happen
      // ============================================

      // PREDICTION 1: Task Deadline Forecast (7 days ahead)
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        const { data: company } = await supabase
          .from('companies')
          .select('id')
          .eq('owner_id', user.id)
          .single();

        if (company) {
          const sevenDaysFromNow = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
          const { data: upcomingTasks } = await supabase
            .from('tasks')
            .select('id, due_date, status')
            .eq('company_id', company.id)
            .lte('due_date', sevenDaysFromNow.toISOString())
            .neq('status', 'completed')
            .is('deleted_at', null);

          const criticalUpcoming = upcomingTasks?.filter(t => {
            const daysUntilDue = Math.ceil((new Date(t.due_date).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
            return daysUntilDue <= 3 && daysUntilDue >= 0;
          }) || [];

          if (criticalUpcoming.length > 5) {
            generatedInsights.push({
              id: `insight-${Date.now()}-forecast`,
              type: 'recommendation',
              priority: 'high',
              title: `üîÆ D·ª± b√°o: ${criticalUpcoming.length} tasks s·∫Øp h·∫øt h·∫°n trong 3 ng√†y`,
              description: `AI d·ª± ƒëo√°n c√≥ ${criticalUpcoming.length} nhi·ªám v·ª• s·∫Ω ƒë·∫øn h·∫°n trong 3 ng√†y t·ªõi. N√™n chu·∫©n b·ªã resources ngay!`,
              data: { upcomingCritical: criticalUpcoming.length, forecast: '3-day window' },
              actions: [
                {
                  id: 'action-forecast',
                  label: 'Xem tasks s·∫Øp ƒë·∫øn h·∫°n',
                  type: 'create_task',
                  params: { redirect: '/tasks?filter=upcoming' },
                },
                {
                  id: 'action-prep',
                  label: 'Chu·∫©n b·ªã resources',
                  type: 'create_task',
                  params: { title: 'Prepare team for upcoming deadline rush' },
                },
              ],
              confidence: 0.92,
              createdAt: new Date(),
              category: 'Predictive Analytics',
            });
          }

          // PREDICTION 2: Burnout Risk (based on workload + time)
          if (metrics.employees.workload) {
            const highWorkloadEmployees = Object.entries(metrics.employees.workload)
              .filter(([_, w]) => w.total > 8 && w.completed < w.total * 0.5); // Many tasks, low completion

            if (highWorkloadEmployees.length > 0) {
              generatedInsights.push({
                id: `insight-${Date.now()}-burnout`,
                type: 'risk',
                priority: 'critical',
                title: `üö® D·ª± b√°o: ${highWorkloadEmployees.length} nh√¢n vi√™n c√≥ nguy c∆° burnout cao`,
                description: `AI ph√°t hi·ªán ${highWorkloadEmployees.length} nh√¢n vi√™n c√≥ workload cao (>8 tasks) nh∆∞ng t·ª∑ l·ªá ho√†n th√†nh th·∫•p (<50%). Nguy c∆° burnout trong 7 ng√†y!`,
                data: { 
                  atRisk: highWorkloadEmployees.length, 
                  prediction: 'High burnout risk within 7 days',
                  avgWorkload: Math.round(highWorkloadEmployees.reduce((sum, [_, w]) => sum + w.total, 0) / highWorkloadEmployees.length)
                },
                actions: [
                  {
                    id: 'action-burnout-1',
                    label: 'üö® Can thi·ªáp ngay l·∫≠p t·ª©c',
                    type: 'create_task',
                    params: { title: 'Emergency workload redistribution meeting' },
                  },
                  {
                    id: 'action-burnout-2',
                    label: 'Gi·∫£m workload',
                    type: 'create_task',
                    params: { title: 'Reduce task load for at-risk employees' },
                  },
                ],
                confidence: 0.88,
                createdAt: new Date(),
                category: 'Predictive Analytics',
              });
            }
          }

          // PREDICTION 3: Attendance Trend (if declining)
          if (metrics.attendance.avgRate < 90 && metrics.attendance.avgRate > 0) {
            const trendPrediction = metrics.attendance.avgRate < 80 ? 'critical decline' : 'concerning trend';
            const projectedRate = Math.max(0, metrics.attendance.avgRate - 5); // Simple linear projection

            generatedInsights.push({
              id: `insight-${Date.now()}-attendance-trend`,
              type: 'anomaly',
              priority: metrics.attendance.avgRate < 80 ? 'critical' : 'high',
              title: `üìä D·ª± b√°o: Attendance c√≥ th·ªÉ gi·∫£m xu·ªëng ${projectedRate}% trong 30 ng√†y`,
              description: `D·ª±a tr√™n xu h∆∞·ªõng hi·ªán t·∫°i (${metrics.attendance.avgRate}%), AI d·ª± ƒëo√°n t·ª∑ l·ªá ch·∫•m c√¥ng c√≥ th·ªÉ gi·∫£m xu·ªëng ${projectedRate}% trong th√°ng t·ªõi n·∫øu kh√¥ng c√≥ can thi·ªáp.`,
              data: { 
                currentRate: metrics.attendance.avgRate, 
                projectedRate,
                trend: trendPrediction,
                timeframe: '30 days'
              },
              actions: [
                {
                  id: 'action-attendance-1',
                  label: 'Ph√¢n t√≠ch nguy√™n nh√¢n',
                  type: 'create_task',
                  params: { title: 'Analyze root cause of attendance decline' },
                },
                {
                  id: 'action-attendance-2',
                  label: 'Improvement program',
                  type: 'create_task',
                  params: { title: 'Launch attendance improvement initiative' },
                },
              ],
              confidence: 0.75,
              createdAt: new Date(),
              category: 'Predictive Analytics',
            });
          }
        }

        // ==========================================
        // PHASE 3: FINANCIAL INTELLIGENCE
        // ==========================================

        // FINANCIAL INSIGHT 1: Low Profit Margin Warning
        if (metrics.financial.revenue > 0) {
          const profitMargin = (metrics.financial.profit / metrics.financial.revenue) * 100;
          
          if (profitMargin < 30) {
            generatedInsights.push({
              id: `insight-${Date.now()}-financial-margin`,
              type: 'risk',
              priority: profitMargin < 15 ? 'critical' : 'high',
              title: `‚ö†Ô∏è ${profitMargin < 15 ? 'KH·∫®N C·∫§P' : 'C·∫£nh b√°o'}: L·ª£i nhu·∫≠n th·∫•p ${profitMargin.toFixed(1)}%`,
              description: `T·ª∑ su·∫•t l·ª£i nhu·∫≠n hi·ªán t·∫°i ch·ªâ ${profitMargin.toFixed(1)}%, th·∫•p h∆°n m·ª©c an to√†n 30%. Doanh thu: ${(metrics.financial.revenue / 1000000).toFixed(0)}M VND, Chi ph√≠: ${(metrics.financial.expenses / 1000000).toFixed(0)}M VND, L·ª£i nhu·∫≠n: ${(metrics.financial.profit / 1000000).toFixed(0)}M VND.`,
              data: { 
                profitMargin,
                revenue: metrics.financial.revenue,
                expenses: metrics.financial.expenses,
                profit: metrics.financial.profit,
                threshold: 30
              },
              actions: [
                {
                  id: 'action-financial-1',
                  label: 'Ph√¢n t√≠ch chi ph√≠',
                  type: 'create_task',
                  params: { title: 'Review and optimize operational expenses' },
                },
                {
                  id: 'action-financial-2',
                  label: 'TƒÉng doanh thu',
                  type: 'create_task',
                  params: { title: 'Develop revenue growth strategy' },
                },
              ],
              confidence: 0.92,
              createdAt: new Date(),
              category: 'Financial Intelligence',
            });
          }
        }

        // FINANCIAL INSIGHT 2: Revenue Decline Alert
        if (metrics.financial.trend === 'down' && metrics.financial.revenue > 0 && company) {
          // Re-fetch transactions for detailed analysis
          const { data: transactionsData } = await supabase
            .from('financial_transactions')
            .select('type, amount, transaction_date')
            .eq('company_id', company.id)
            .gte('transaction_date', new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString())
            .is('deleted_at', null);
          
          const transactions = transactionsData || [];
          const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
          const sixtyDaysAgo = Date.now() - 60 * 24 * 60 * 60 * 1000;
          
          const recentRevenue = transactions.filter(t => 
            t.type === 'revenue' && new Date(t.transaction_date).getTime() > thirtyDaysAgo
          ).reduce((sum, t) => sum + Number(t.amount), 0);
          
          const previousRevenue = transactions.filter(t => 
            t.type === 'revenue' && 
            new Date(t.transaction_date).getTime() > sixtyDaysAgo &&
            new Date(t.transaction_date).getTime() <= thirtyDaysAgo
          ).reduce((sum, t) => sum + Number(t.amount), 0);
          
          if (previousRevenue > 0) {
            const declinePercent = ((previousRevenue - recentRevenue) / previousRevenue) * 100;
            
            if (declinePercent > 10) {
              generatedInsights.push({
                id: `insight-${Date.now()}-financial-decline`,
                type: 'anomaly',
                priority: declinePercent > 20 ? 'critical' : 'high',
                title: `üìâ C·∫£nh b√°o: Doanh thu gi·∫£m ${declinePercent.toFixed(1)}% trong 30 ng√†y`,
                description: `Doanh thu th√°ng g·∫ßn ƒë√¢y: ${(recentRevenue / 1000000).toFixed(0)}M VND, gi·∫£m ${declinePercent.toFixed(1)}% so v·ªõi th√°ng tr∆∞·ªõc (${(previousRevenue / 1000000).toFixed(0)}M VND). C·∫ßn h√†nh ƒë·ªông ngay ƒë·ªÉ ƒë·∫£o ng∆∞·ª£c xu h∆∞·ªõng.`,
                data: { 
                  recentRevenue,
                  previousRevenue,
                  declinePercent,
                  timeframe: '30 days'
                },
                actions: [
                  {
                    id: 'action-revenue-1',
                    label: 'Ph√¢n t√≠ch nguy√™n nh√¢n',
                    type: 'create_task',
                    params: { title: 'Analyze revenue decline causes' },
                  },
                  {
                    id: 'action-revenue-2',
                    label: 'Recovery plan',
                    type: 'create_task',
                    params: { title: 'Create revenue recovery action plan' },
                  },
                ],
                confidence: 0.85,
                createdAt: new Date(),
                category: 'Financial Intelligence',
              });
            }
          }
        }

        // FINANCIAL INSIGHT 3: High Expense Ratio Warning
        if (metrics.financial.revenue > 0) {
          const expenseRatio = (metrics.financial.expenses / metrics.financial.revenue) * 100;
          
          if (expenseRatio > 70) {
            generatedInsights.push({
              id: `insight-${Date.now()}-financial-expenses`,
              type: 'risk',
              priority: expenseRatio > 85 ? 'critical' : 'high',
              title: `üö® Chi ph√≠ cao: ${expenseRatio.toFixed(1)}% doanh thu`,
              description: `Chi ph√≠ chi·∫øm ${expenseRatio.toFixed(1)}% doanh thu (${(metrics.financial.expenses / 1000000).toFixed(0)}M / ${(metrics.financial.revenue / 1000000).toFixed(0)}M VND). M·ª©c an to√†n l√† d∆∞·ªõi 70%. Nguy c∆° d√≤ng ti·ªÅn √¢m.`,
              data: { 
                expenseRatio,
                expenses: metrics.financial.expenses,
                revenue: metrics.financial.revenue,
                threshold: 70
              },
              actions: [
                {
                  id: 'action-expense-1',
                  label: 'Cost reduction',
                  type: 'create_task',
                  params: { title: 'Identify and implement cost-cutting measures' },
                },
                {
                  id: 'action-expense-2',
                  label: 'Budget review',
                  type: 'create_task',
                  params: { title: 'Review and optimize department budgets' },
                },
              ],
              confidence: 0.88,
              createdAt: new Date(),
              category: 'Financial Intelligence',
            });
          }
        }

        // FINANCIAL PREDICTION 1: Cash Flow Forecast (7-day)
        if (metrics.financial.revenue > 0 && metrics.financial.expenses > 0) {
          // Calculate daily averages
          const daysInData = 90;
          const dailyRevenue = metrics.financial.revenue / daysInData;
          const dailyExpenses = metrics.financial.expenses / daysInData;
          const dailyProfit = dailyRevenue - dailyExpenses;
          
          // Project 7-day cash flow
          const projectedProfit7d = dailyProfit * 7;
          const projectedRevenue7d = dailyRevenue * 7;
          const projectedExpenses7d = dailyExpenses * 7;
          
          generatedInsights.push({
            id: `insight-${Date.now()}-financial-forecast`,
            type: 'prediction',
            priority: projectedProfit7d < 0 ? 'critical' : 'medium',
            title: `üìä D·ª± b√°o d√≤ng ti·ªÅn 7 ng√†y: ${projectedProfit7d < 0 ? 'üö® √ÇM' : '‚úÖ D∆Ø∆†NG'} ${(projectedProfit7d / 1000000).toFixed(0)}M VND`,
            description: `D·ª±a tr√™n 90 ng√†y d·ªØ li·ªáu, AI d·ª± ƒëo√°n trong 7 ng√†y t·ªõi: Thu ${(projectedRevenue7d / 1000000).toFixed(0)}M, Chi ${(projectedExpenses7d / 1000000).toFixed(0)}M, L√£i/L·ªó ${(projectedProfit7d / 1000000).toFixed(0)}M VND. Trung b√¨nh m·ªói ng√†y: ${(dailyProfit / 1000000).toFixed(1)}M VND.`,
            data: { 
              projectedRevenue7d,
              projectedExpenses7d,
              projectedProfit7d,
              dailyRevenue,
              dailyExpenses,
              dailyProfit,
              timeframe: '7 days'
            },
            actions: projectedProfit7d < 0 ? [
              {
                id: 'action-cashflow-1',
                label: 'Kh·∫©n c·∫•p: Gi·∫£i ph√°p d√≤ng ti·ªÅn',
                type: 'create_task',
                params: { title: 'URGENT: Address negative cash flow projection' },
              },
            ] : [],
            confidence: 0.78,
            createdAt: new Date(),
            category: 'Financial Intelligence',
          });
        }
      }

      // ============================================
      // EXISTING INSIGHTS (Real-time Detection)
      // ============================================

      // Critical: Overdue tasks detection
      if (metrics.tasks.overdue > 5) {
        generatedInsights.push({
          id: `insight-${Date.now()}-1`,
          type: 'risk',
          priority: 'critical',
          title: `‚ö†Ô∏è ${metrics.tasks.overdue} nhi·ªám v·ª• qu√° h·∫°n`,
          description: `C√≥ ${metrics.tasks.overdue} nhi·ªám v·ª• ƒëang qu√° h·∫°n, ·∫£nh h∆∞·ªüng ƒë·∫øn ti·∫øn ƒë·ªô d·ª± √°n. C·∫ßn can thi·ªáp ngay l·∫≠p t·ª©c.`,
          data: { overdueTasks: metrics.tasks.overdue, totalTasks: metrics.tasks.total },
          actions: [
            {
              id: 'action-1',
              label: 'Xem danh s√°ch nhi·ªám v·ª• qu√° h·∫°n',
              type: 'create_task',
              params: { redirect: '/tasks?filter=overdue' },
            },
            {
              id: 'action-2',
              label: 'G·ª≠i c·∫£nh b√°o ƒë·∫øn managers',
              type: 'send_alert',
              params: { recipients: 'managers', message: 'Critical overdue tasks' },
            },
          ],
          confidence: 0.95,
          createdAt: new Date(),
          category: 'Task Management',
        });
      }

      // Opportunity: High task completion rate
      if (metrics.tasks.completionRate >= 90) {
        generatedInsights.push({
          id: `insight-${Date.now()}-2`,
          type: 'opportunity',
          priority: 'medium',
          title: `üéØ T·ª∑ l·ªá ho√†n th√†nh nhi·ªám v·ª• xu·∫•t s·∫Øc: ${metrics.tasks.completionRate}%`,
          description: `Team ƒëang c√≥ hi·ªáu su·∫•t r·∫•t t·ªët. ƒê√¢y l√† th·ªùi ƒëi·ªÉm t·ªët ƒë·ªÉ tƒÉng scope ho·∫∑c th∆∞·ªüng cho ƒë·ªôi ng≈©.`,
          data: { completionRate: metrics.tasks.completionRate },
          actions: [
            {
              id: 'action-3',
              label: 'T·∫°o ch∆∞∆°ng tr√¨nh khen th∆∞·ªüng',
              type: 'create_task',
              params: { title: 'Reward high-performing team' },
            },
          ],
          confidence: 0.88,
          createdAt: new Date(),
          category: 'Team Performance',
        });
      }

      // NEW: Employee workload analysis
      if (metrics.employees.workload) {
        const workloadEntries = Object.entries(metrics.employees.workload);
        const overloadedEmployees = workloadEntries.filter(([_, w]) => w.total > 10);
        const underutilizedEmployees = workloadEntries.filter(([_, w]) => w.total < 3);
        
        if (overloadedEmployees.length > 0) {
          generatedInsights.push({
            id: `insight-${Date.now()}-workload`,
            type: 'risk',
            priority: 'high',
            title: `‚ö†Ô∏è ${overloadedEmployees.length} nh√¢n vi√™n qu√° t·∫£i`,
            description: `C√≥ ${overloadedEmployees.length} nh√¢n vi√™n ƒëang x·ª≠ l√Ω qu√° nhi·ªÅu tasks (>10), nguy c∆° burnout cao!`,
            data: { overloaded: overloadedEmployees.length },
            actions: [
              {
                id: 'action-workload',
                label: 'Ph√¢n ph·ªëi l·∫°i workload',
                type: 'create_task',
                params: { title: 'Redistribute workload to prevent burnout' },
              },
            ],
            confidence: 0.90,
            createdAt: new Date(),
            category: 'Team Capacity',
          });
        }
        
        if (underutilizedEmployees.length > 0) {
          generatedInsights.push({
            id: `insight-${Date.now()}-underutilized`,
            type: 'opportunity',
            priority: 'medium',
            title: `üí° ${underutilizedEmployees.length} nh√¢n vi√™n c√≥ capacity`,
            description: `C√≥ ${underutilizedEmployees.length} nh√¢n vi√™n ƒëang c√≥ √≠t tasks (<3), c√≥ th·ªÉ assign th√™m vi·ªác.`,
            data: { underutilized: underutilizedEmployees.length },
            actions: [
              {
                id: 'action-assign',
                label: 'Assign th√™m tasks',
                type: 'create_task',
                params: { title: 'Assign tasks to available team members' },
              },
            ],
            confidence: 0.85,
            createdAt: new Date(),
            category: 'Team Capacity',
          });
        }
      }

      // Anomaly: Low attendance rate
      if (metrics.attendance.avgRate < 85 && metrics.attendance.avgRate > 0) {
        generatedInsights.push({
          id: `insight-${Date.now()}-3`,
          type: 'anomaly',
          priority: 'high',
          title: `üìâ T·ª∑ l·ªá ch·∫•m c√¥ng th·∫•p: ${metrics.attendance.avgRate}%`,
          description: `T·ª∑ l·ªá ch·∫•m c√¥ng ƒëang th·∫•p h∆°n m·ª©c chu·∫©n (90%). C√≥ th·ªÉ c√≥ v·∫•n ƒë·ªÅ v·ªÅ morale ho·∫∑c h·ªá th·ªëng.`,
          data: { avgRate: metrics.attendance.avgRate, absentCount: metrics.attendance.absentCount },
          actions: [
            {
              id: 'action-4',
              label: 'Ki·ªÉm tra nguy√™n nh√¢n',
              type: 'create_task',
              params: { title: 'Investigate attendance issues' },
            },
            {
              id: 'action-5',
              label: 'H·ªçp v·ªõi HR',
              type: 'schedule_meeting',
              params: { topic: 'Attendance concerns' },
            },
          ],
          confidence: 0.82,
          createdAt: new Date(),
          category: 'Attendance',
        });
      }

      // Recommendation: KPI tracking
      if (metrics.kpi.percentage < 70 && metrics.kpi.total > 0) {
        generatedInsights.push({
          id: `insight-${Date.now()}-4`,
          type: 'recommendation',
          priority: 'high',
          title: `üéØ Ch·ªâ ${metrics.kpi.percentage}% KPI ƒë·∫°t m·ª•c ti√™u`,
          description: `Nhi·ªÅu KPI ƒëang kh√¥ng ƒë·∫°t target. C·∫ßn review v√† ƒëi·ªÅu ch·ªânh chi·∫øn l∆∞·ª£c ho·∫∑c m·ª•c ti√™u.`,
          data: { achieved: metrics.kpi.achieved, total: metrics.kpi.total },
          actions: [
            {
              id: 'action-6',
              label: 'Review KPI targets',
              type: 'create_task',
              params: { title: 'Review and adjust KPI targets' },
            },
            {
              id: 'action-7',
              label: 'H·ªçp strategic planning',
              type: 'schedule_meeting',
              params: { topic: 'KPI review meeting' },
            },
          ],
          confidence: 0.91,
          createdAt: new Date(),
          category: 'Strategic Planning',
        });
      }

      return generatedInsights;
    },
    enabled: !!metrics && autoAnalysisEnabled,
  });

  // Chat with AI Assistant (Powered by Gemini)
  const sendMessageMutation = useMutation({
    mutationFn: async (message: string) => {
      // Build context for AI
      const context = {
        tasks: {
          total: metrics?.tasks.total || 0,
          overdue: metrics?.tasks.overdue || 0,
          completed: metrics?.tasks.completed || 0,
          completion_rate: metrics?.tasks.completionRate || 0,
        },
        team: {
          total: metrics?.employees.total || 0,
          active: metrics?.employees.active || 0,
        },
        recent_issues: insights?.slice(0, 3).map(i => i.title) || [],
      };

      // Build conversation history
      const messages: AIServiceMessage[] = [
        {
          role: 'system',
          content: `You are JARVIS - an AI business analyst for a Vietnamese CEO. 

Current Company Status:
- Tasks: ${context.tasks.total} total, ${context.tasks.overdue} overdue, ${context.tasks.completed} completed (${context.tasks.completion_rate}% completion rate)
- Team: ${context.team.total} members, ${context.team.active} active
- Recent Issues: ${context.recent_issues.join(', ') || 'None'}

Guidelines:
1. Respond in Vietnamese (friendly but professional)
2. Be concise (2-4 sentences max)
3. Focus on actionable insights
4. Use emojis appropriately
5. If data is missing, acknowledge it and suggest solutions

CEO wants INSIGHTS, not raw data. Think like a strategic advisor.`,
        },
        // Include recent chat history for context
        ...chatMessages.slice(-4).map(msg => ({
          role: msg.role === 'user' ? 'user' as const : 'assistant' as const,
          content: msg.content,
        })),
        {
          role: 'user',
          content: message,
        },
      ];

      // Call AI service (Gemini)
      const aiResponse = await aiService.chat(messages);

      return {
        response: aiResponse.content,
        confidence: aiResponse.confidence,
        relatedInsights: insights?.filter(i => 
          i.priority === 'critical' || i.priority === 'high'
        ).slice(0, 2) || [],
      };
    },
    onSuccess: async (data) => {
      const assistantMessage: ChatMessage = {
        id: `msg-${Date.now()}`,
        role: 'assistant',
        content: data.response,
        timestamp: new Date(),
        insights: data.relatedInsights,
      };
      setChatMessages(prev => [...prev, assistantMessage]);
      
      // Save AI response to database
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          const { data: company } = await supabase
            .from('companies')
            .select('id')
            .eq('owner_id', user.id)
            .single();

          if (company) {
            await supabase.from('ai_chat_history').insert({
              company_id: company.id,
              user_id: user.id,
              session_id: sessionId,
              role: 'assistant',
              content: assistantMessage.content,
              insights: data.relatedInsights || [],
              metadata: { confidence: 0.9, provider: 'openai' },
            });
          }
        }
      } catch (error) {
        console.error('Failed to save AI response:', error);
      }
    },
  });

  const handleSendMessage = async () => {
    if (!inputMessage.trim()) return;

    // INTELLIGENT AUTO-DELEGATE TRIGGER
    // Detect keywords: "giao vi·ªác", "ph√¢n c√¥ng", "delegate", "assign tasks"
    const delegationKeywords = ['giao vi·ªác', 'giao 10 vi·ªác', 'ph√¢n c√¥ng', 'delegate', 'assign task', 'ph√¢n b·ªï c√¥ng vi·ªác'];
    const shouldAutoDelegate = delegationKeywords.some(keyword => 
      inputMessage.toLowerCase().includes(keyword.toLowerCase())
    );

    // DEBUG: Log detection status
    console.log('üîç Auto-Delegate Detection:', {
      inputMessage,
      shouldAutoDelegate,
      hasMetrics: !!metrics,
      hasInsights: !!insights,
      willTrigger: shouldAutoDelegate && !!metrics && !!insights
    });

    // ALLOW AUTO-DELEGATE even without full metrics (for testing)
    // In production, you may want to require metrics && insights
    if (shouldAutoDelegate) {
      console.log('üéØ Detected delegation intent, triggering Auto-Delegate...');
      
      if (!metrics || !insights) {
        console.warn('‚ö†Ô∏è Auto-Delegate: Missing metrics/insights, using basic mode');
      }
      
      // Add user message to chat first
      const userMessage: ChatMessage = {
        id: `msg-${Date.now()}`,
        role: 'user',
        content: inputMessage,
        timestamp: new Date(),
      };
      setChatMessages(prev => [...prev, userMessage]);
      
      // Add AI confirmation message
      const confirmMessage: ChatMessage = {
        id: `msg-${Date.now() + 1}`,
        role: 'assistant',
        content: 'ü§ñ ƒê√£ ph√°t hi·ªán y√™u c·∫ßu giao vi·ªác! ƒêang ph√¢n t√≠ch t√¨nh h√¨nh doanh nghi·ªáp v√† t·∫°o danh s√°ch tasks th√¥ng minh...\n\n‚è≥ Vui l√≤ng ch·ªù 2-3 gi√¢y...',
        timestamp: new Date(),
      };
      setChatMessages(prev => [...prev, confirmMessage]);
      
      // Trigger auto-delegate after short delay
      setTimeout(() => {
        handleAutoDelegateClick();
      }, 1000);
      
      setInputMessage('');
      return;
    }

    const userMessage: ChatMessage = {
      id: `msg-${Date.now()}`,
      role: 'user',
      content: inputMessage,
      timestamp: new Date(),
    };

    setChatMessages(prev => [...prev, userMessage]);
    
    // Save user message to database
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        const { data: company } = await supabase
          .from('companies')
          .select('id')
          .eq('owner_id', user.id)
          .single();

        if (company) {
          await supabase.from('ai_chat_history').insert({
            company_id: company.id,
            user_id: user.id,
            session_id: sessionId,
            role: 'user',
            content: userMessage.content,
          });
        }
      }
    } catch (error) {
      console.error('Failed to save message:', error);
    }
    
    sendMessageMutation.mutate(inputMessage);
    setInputMessage('');
  };

  /**
   * AUTO-DELEGATE FEATURE
   * Elon Musk Philosophy: "The best meetings are no meetings. The best delegation is automatic."
   * 
   * Uses AI Assistant's complete business context to generate intelligent task suggestions:
   * - Current metrics (tasks, employees, financial health)
   * - AI insights (risks, opportunities, predictions)
   * - Workload distribution (who's overloaded, who's available)
   * - Financial trends (what needs attention NOW)
   * 
   * Result: CEO clicks button ‚Üí AI generates 3-5 urgent tasks ‚Üí Navigate to delegator ‚Üí 1-click approve ‚Üí Done!
   */
  const handleAutoDelegateClick = async () => {
    try {
      // Build business context (with fallback for missing data)
      const context = metrics && insights ? {
        // Task urgency
        overdueTasks: metrics.tasks.overdue,
        totalTasks: metrics.tasks.total,
        completionRate: metrics.tasks.completionRate,
        
        // Employee status
        activeEmployees: metrics.employees.active,
        workloadIssues: Object.entries(metrics.employees.workload || {})
          .filter(([_, wl]: [string, any]) => wl.total > 10)
          .length,
        
        // Financial health
        financialTrend: metrics.financial.trend,
        profit: metrics.financial.profit,
        
        // AI insights (critical + high priority only)
        criticalInsights: insights
          .filter(i => i.priority === 'critical' || i.priority === 'high')
          .map(i => ({
            type: i.type,
            title: i.title,
            category: i.category,
          })),
      } : null;

      // Generate AI-powered task suggestions
      const prompt = context 
        ? `B·∫°n l√† AI Assistant c·ªßa CEO. Ph√¢n t√≠ch t√¨nh h√¨nh doanh nghi·ªáp hi·ªán t·∫°i v√† ƒë·ªÅ xu·∫•t 3-5 nhi·ªám v·ª• C·∫¶N GIAO NGAY ƒë·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ:

üìä T√åNH H√åNH HI·ªÜN T·∫†I:
- Tasks: ${context.overdueTasks} tasks qu√° h·∫°n / ${context.totalTasks} t·ªïng (t·ªâ l·ªá ho√†n th√†nh: ${context.completionRate}%)
- Nh√¢n vi√™n: ${context.activeEmployees} ng∆∞·ªùi ƒëang ho·∫°t ƒë·ªông, ${context.workloadIssues} ng∆∞·ªùi c√≥ workload cao (>10 tasks)
- T√†i ch√≠nh: L·ª£i nhu·∫≠n ${context.profit.toLocaleString('vi-VN')} VNƒê, xu h∆∞·ªõng ${context.financialTrend === 'up' ? '‚ÜóÔ∏è tƒÉng' : context.financialTrend === 'down' ? '‚ÜòÔ∏è gi·∫£m' : '‚Üí ·ªïn ƒë·ªãnh'}
- C·∫£nh b√°o AI: ${context.criticalInsights.length} insights m·ª©c ƒë·ªô cao/critical

üéØ C√ÅC V·∫§N ƒê·ªÄ C·∫¶N GI·∫¢I QUY·∫æT:
${context.criticalInsights.map((insight, idx) => `${idx + 1}. [${insight.category}] ${insight.title}`).join('\n')}

üìù Y√äU C·∫¶U:
H√£y ƒë·ªÅ xu·∫•t 3-5 nhi·ªám v·ª• c·ª• th·ªÉ ƒë·ªÉ CEO giao ngay. Format:

**TASK 1: [Ti√™u ƒë·ªÅ ng·∫Øn g·ªçn]**
M√¥ t·∫£: [Gi·∫£i th√≠ch t·∫°i sao c·∫ßn l√†m ngay]
∆Øu ti√™n: high/medium
Danh m·ª•c: [operations/hr/finance/sales]
Deadline: [s·ªë ng√†y t·ª´ h√¥m nay]

**TASK 2: ...**

L∆∞u √Ω: 
- T·∫≠p trung v√†o v·∫•n ƒë·ªÅ C·∫§P B√ÅC nh·∫•t
- Nhi·ªám v·ª• ph·∫£i TH·ª∞C T·∫æ v√† c√≥ th·ªÉ giao ngay
- ƒê·ªÅ xu·∫•t deadline h·ª£p l√Ω (1-7 ng√†y)
- S·ª≠ d·ª•ng ti·∫øng Vi·ªát t·ª± nhi√™n`
        : `B·∫°n l√† AI Assistant c·ªßa CEO. ƒê·ªÅ xu·∫•t 5 nhi·ªám v·ª• quan tr·ªçng ƒë·ªÉ qu·∫£n l√Ω doanh nghi·ªáp hi·ªáu qu·∫£:

üìù Y√äU C·∫¶U:
ƒê·ªÅ xu·∫•t 5 nhi·ªám v·ª• thi·∫øt y·∫øu cho m·ªôt CEO. Format:

**TASK 1: [Ti√™u ƒë·ªÅ]**
M√¥ t·∫£: [Chi ti·∫øt nhi·ªám v·ª•]
∆Øu ti√™n: high/medium
Danh m·ª•c: [operations/hr/finance/sales]
Deadline: [s·ªë ng√†y t·ª´ h√¥m nay]

L∆∞u √Ω: S·ª≠ d·ª•ng ti·∫øng Vi·ªát t·ª± nhi√™n.`;

      console.log('ü§ñ Auto-Delegate: Generating AI task suggestions...', { hasContext: !!context });

      const response = await aiService.chat([
        { role: 'system', content: 'B·∫°n l√† AI Assistant chuy√™n ph√¢n t√≠ch doanh nghi·ªáp v√† ƒë·ªÅ xu·∫•t task delegation th√¥ng minh.' },
        { role: 'user', content: prompt }
      ]);

      const aiSuggestions = response.content;

      console.log('‚úÖ Auto-Delegate: AI generated suggestions', { length: aiSuggestions.length });

      // Switch to delegator tab and pass data
      setAutoDelegateData({
        autoGenerated: aiSuggestions,
        businessContext: context,
      });
      setActiveTab('delegator');

    } catch (error) {
      console.error('‚ùå Auto-Delegate failed:', error);
      // Fallback: Switch to delegator tab without pre-fill
      setActiveTab('delegator');
    }
  };

  const executeAction = async (action: AIAction) => {
    try {
      console.log('üé¨ Executing AI action:', action);

      // Get user and company
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data: company } = await supabase
        .from('companies')
        .select('id')
        .eq('owner_id', user.id)
        .single();

      if (!company) throw new Error('Company not found');

      switch (action.type) {
        case 'create_task': {
          // AUTO-CREATE TASK from AI insight
          const taskTitle = action.params.title || action.label;
          const { error: taskError } = await supabase
            .from('tasks')
            .insert({
              company_id: company.id,
              title: taskTitle,
              description: `ü§ñ Task t·ª± ƒë·ªông t·∫°o b·ªüi AI Assistant\n\nL√Ω do: ${action.label}\nƒê·ªô tin c·∫≠y: High\nNg√†y t·∫°o: ${format(new Date(), 'dd/MM/yyyy HH:mm', { locale: vi })}`,
              status: 'pending',
              category: 'admin',
              priority: 'high',
              due_date: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(), // 3 days from now
              created_by: user.id,
            })
            .select()
            .single();

          if (taskError) throw taskError;

          alert(`‚úÖ Task ƒë√£ ƒë∆∞·ª£c t·∫°o t·ª± ƒë·ªông: "${taskTitle}"\n\nü§ñ AI ƒë√£ ph√¢n t√≠ch v√† t·∫°o task ƒë·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ!`);
          
          // Refresh insights after creating task
          queryClient.invalidateQueries({ queryKey: ['ceo-ai-insights'] });
          break;
        }

        case 'send_alert':
          // TODO: Implement notification system
          alert(`üîî ƒê√£ g·ª≠i c·∫£nh b√°o ƒë·∫øn: ${action.params.recipients}\nN·ªôi dung: ${action.params.message}`);
          break;

        case 'schedule_meeting':
          // TODO: Implement calendar integration
          alert(`üìÖ ƒê√£ l√™n l·ªãch meeting: ${action.params.topic}\n\n(T√≠nh nƒÉng calendar ƒëang ph√°t tri·ªÉn)`);
          break;

        case 'approve':
          // TODO: Implement approval workflow
          alert(`‚úÖ ƒê√£ approved: ${action.label}`);
          break;

        default:
          console.warn('Unknown action type:', action.type);
      }
    } catch (error) {
      console.error('‚ùå Action execution failed:', error);
      alert(`L·ªói khi th·ª±c hi·ªán action: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  };

  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [chatMessages]);

  // Load chat history on mount
  useEffect(() => {
    const loadChatHistory = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return;

        const { data: company } = await supabase
          .from('companies')
          .select('id')
          .eq('owner_id', user.id)
          .single();

        if (!company) return;

        // Get most recent session
        const { data: recentSession } = await supabase
          .from('ai_chat_history')
          .select('session_id')
          .eq('user_id', user.id)
          .eq('company_id', company.id)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();

        if (recentSession) {
          // Load existing session
          const { data: history } = await supabase
            .from('ai_chat_history')
            .select('id, role, content, insights, created_at')
            .eq('session_id', recentSession.session_id)
            .order('created_at', { ascending: true });

          if (history && history.length > 0) {
            const loadedMessages: ChatMessage[] = history.map(h => ({
              id: h.id,
              role: h.role as 'user' | 'assistant',
              content: h.content,
              timestamp: new Date(h.created_at),
              insights: h.insights || undefined,
            }));
            setChatMessages(loadedMessages);
            setSessionId(recentSession.session_id);
            setIsLoadingHistory(false);
            return;
          }
        }

        // No history found - show welcome message
        const welcomeMsg: ChatMessage = {
          id: 'welcome',
          role: 'assistant',
          content: `Ch√†o CEO! üëã T√¥i l√† AI Assistant - nghƒ© nh∆∞ JARVIS nh∆∞ng cho business.\n\nü§ñ **PREDICTIVE ANALYTICS + FINANCIAL INTELLIGENCE ƒë√£ active!**\n\n‚ú® **Kh·∫£ nƒÉng:**\n‚Ä¢ üîÆ D·ª± b√°o v·∫•n ƒë·ªÅ 7 ng√†y tr∆∞·ªõc\n‚Ä¢ üí∞ Ph√¢n t√≠ch doanh thu & l·ª£i nhu·∫≠n\n‚Ä¢ üö® C·∫£nh b√°o burnout & workload\n‚Ä¢ üìä D·ª± ƒëo√°n cash flow\n‚Ä¢ üéØ T·ª± ƒë·ªông t·∫°o tasks t·ª´ insights\n\nüí¨ **H·ªèi t√¥i:**\n‚Ä¢ "T√¨nh h√¨nh t√†i ch√≠nh th·∫ø n√†o?"\n‚Ä¢ "C√≥ r·ªßi ro g√¨ kh√¥ng?"\n‚Ä¢ "D·ª± b√°o d√≤ng ti·ªÅn 7 ng√†y t·ªõi?"\n‚Ä¢ "Team n√†o overload?"`,
          timestamp: new Date(),
        };
        setChatMessages([welcomeMsg]);
        
        // Save welcome message to DB
        await supabase.from('ai_chat_history').insert({
          company_id: company.id,
          user_id: user.id,
          session_id: sessionId,
          role: 'assistant',
          content: welcomeMsg.content,
          metadata: { type: 'welcome' },
        });
      } catch (error) {
        console.error('Error loading chat history:', error);
      } finally {
        setIsLoadingHistory(false);
      }
    };

    loadChatHistory();
  }, []);

  const priorityColors = {
    low: 'bg-blue-100 text-blue-800',
    medium: 'bg-yellow-100 text-yellow-800',
    high: 'bg-orange-100 text-orange-800',
    critical: 'bg-red-100 text-red-800',
  };

  const typeIcons = {
    opportunity: TrendingUp,
    risk: AlertTriangle,
    anomaly: BarChart3,
    recommendation: Lightbulb,
    prediction: Brain,
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold flex items-center gap-3">
            <Bot className="h-8 w-8 text-purple-600" />
            CEO AI Assistant
            <Badge variant="outline" className="ml-2 text-xs">
              <Sparkles className="h-3 w-3 mr-1" />
              {aiProvider.status}
            </Badge>
          </h1>
          <p className="text-muted-foreground mt-1">
            Powered by {aiProvider.provider === 'gemini' ? 'Google Gemini' : aiProvider.provider} ‚Ä¢ Real-time analysis ‚Ä¢ Predictive insights
          </p>
        </div>
        <div className="flex items-center gap-4">
          <div className="flex items-center gap-2">
            <Switch
              checked={autoAnalysisEnabled}
              onCheckedChange={setAutoAnalysisEnabled}
              id="auto-analysis"
            />
            <Label htmlFor="auto-analysis" className="text-sm">Auto Analysis</Label>
          </div>
          <Button 
            variant="default" 
            size="sm"
            onClick={() => setActiveTab('delegator')}
            className="bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white font-semibold shadow-lg"
          >
            <ListTodo className="h-4 w-4 mr-2" />
            Task Delegator
          </Button>
          <Button variant="outline" size="sm">
            <Settings className="h-4 w-4 mr-2" />
            Configure
          </Button>
        </div>
      </div>

      {/* Tabs for switching between Assistant and Task Delegator */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
        <TabsList className="grid w-full max-w-md grid-cols-2">
          <TabsTrigger value="assistant" className="flex items-center gap-2">
            <Bot className="h-4 w-4" />
            AI Chat
          </TabsTrigger>
          <TabsTrigger value="delegator" className="flex items-center gap-2">
            <ListTodo className="h-4 w-4" />
            Task Delegator
          </TabsTrigger>
        </TabsList>

        <TabsContent value="assistant" className="mt-6 space-y-6">
          {/* Real-time Metrics Dashboard */}
          <div className="grid gap-4 md:grid-cols-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Active Team</p>
                <p className="text-2xl font-bold">{metrics?.employees.active || 0}</p>
                <p className="text-xs text-green-600 mt-1">
                  {metrics?.employees.total || 0} total
                </p>
              </div>
              <Users className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Task Completion</p>
                <p className="text-2xl font-bold">{metrics?.tasks.completionRate || 0}%</p>
                <p className="text-xs text-muted-foreground mt-1">
                  {metrics?.tasks.completed}/{metrics?.tasks.total} done
                </p>
              </div>
              <CheckCircle className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">KPI Achievement</p>
                <p className="text-2xl font-bold">{metrics?.kpi.percentage || 0}%</p>
                <p className="text-xs text-muted-foreground mt-1">
                  {metrics?.kpi.achieved}/{metrics?.kpi.total} achieved
                </p>
              </div>
              <Target className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">AI Insights</p>
                <p className="text-2xl font-bold">{insights?.length || 0}</p>
                <p className="text-xs text-orange-600 mt-1">
                  {insights?.filter(i => i.priority === 'critical' || i.priority === 'high').length || 0} urgent
                </p>
              </div>
              <Brain className="h-8 w-8 text-orange-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <div className="grid gap-6 lg:grid-cols-3">
        {/* AI Insights Panel */}
        <Card className="lg:col-span-1">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Sparkles className="h-5 w-5 text-yellow-500" />
              AI Insights
            </CardTitle>
            <CardDescription>Real-time intelligence from your data</CardDescription>
          </CardHeader>
          <CardContent className="space-y-3 max-h-[600px] overflow-y-auto">
            {insightsLoading ? (
              <p className="text-center text-muted-foreground py-8">Analyzing...</p>
            ) : insights && insights.length > 0 ? (
              insights.map((insight) => {
                const IconComponent = typeIcons[insight.type];
                return (
                  <div key={insight.id} className="border rounded-lg p-4 space-y-3">
                    <div className="flex items-start justify-between">
                      <div className="flex items-start gap-2 flex-1">
                        <IconComponent className="h-5 w-5 mt-0.5 flex-shrink-0" />
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1">
                            <Badge className={cn('text-xs', priorityColors[insight.priority])}>
                              {insight.priority}
                            </Badge>
                            <span className="text-xs text-muted-foreground">
                              {Math.round(insight.confidence * 100)}% confidence
                            </span>
                          </div>
                          <h4 className="font-semibold text-sm mb-1">{insight.title}</h4>
                          <p className="text-xs text-muted-foreground">{insight.description}</p>
                        </div>
                      </div>
                    </div>
                    
                    {insight.actions.length > 0 && (
                      <div className="space-y-1 pt-2 border-t">
                        {insight.actions.map((action) => (
                          <Button
                            key={action.id}
                            variant="outline"
                            size="sm"
                            className="w-full justify-start text-xs h-8"
                            onClick={() => executeAction(action)}
                          >
                            <Play className="h-3 w-3 mr-2" />
                            {action.label}
                          </Button>
                        ))}
                      </div>
                    )}
                  </div>
                );
              })
            ) : (
              <div className="text-center py-8 text-muted-foreground">
                <Brain className="h-12 w-12 mx-auto mb-3 opacity-50" />
                <p className="text-sm">No critical insights right now</p>
                <p className="text-xs">Everything looks good! üéâ</p>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Chat Interface */}
        <Card className="lg:col-span-2">
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle className="flex items-center gap-2">
                  <MessageSquare className="h-5 w-5" />
                  Chat with AI Assistant
                </CardTitle>
                <CardDescription>Ask anything about your business ‚Ä¢ L·ªãch s·ª≠ ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông</CardDescription>
              </div>
              <Button
                variant="outline"
                size="sm"
                onClick={() => {
                  const newSessionId = crypto.randomUUID();
                  setSessionId(newSessionId);
                  setChatMessages([]);
                  setIsLoadingHistory(false);
                }}
                className="flex items-center gap-2"
              >
                <RefreshCw className="h-4 w-4" />
                New Chat
              </Button>
            </div>
          </CardHeader>
          <CardContent>
            {/* Chat Messages */}
            <div className="space-y-4 mb-4 h-[500px] overflow-y-auto border rounded-lg p-4 bg-gray-50">
              {chatMessages.map((message) => (
                <div
                  key={message.id}
                  className={cn(
                    'flex gap-3',
                    message.role === 'user' ? 'justify-end' : 'justify-start'
                  )}
                >
                  {message.role === 'assistant' && (
                    <div className="flex-shrink-0">
                      <div className="w-8 h-8 rounded-full bg-purple-600 flex items-center justify-center">
                        <Bot className="h-5 w-5 text-white" />
                      </div>
                    </div>
                  )}
                  <div
                    className={cn(
                      'max-w-[80%] rounded-lg p-3',
                      message.role === 'user'
                        ? 'bg-blue-600 text-white'
                        : 'bg-white border'
                    )}
                  >
                    <p className="text-sm whitespace-pre-wrap">{message.content}</p>
                    <div className="flex items-center justify-between mt-2">
                      <p className="text-xs opacity-70">
                        {format(message.timestamp, 'HH:mm', { locale: vi })}
                      </p>
                      {message.role === 'assistant' && message.content.length > 100 && (
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 text-xs text-purple-600 hover:text-purple-800 hover:bg-purple-50 px-2"
                          onClick={() => handleSendToTaskDelegator(message.content)}
                        >
                          <ArrowRight className="h-3 w-3 mr-1" />
                          Chuy·ªÉn sang Task Delegator
                        </Button>
                      )}
                    </div>
                  </div>
                  {message.role === 'user' && (
                    <div className="flex-shrink-0">
                      <div className="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-white font-bold">
                        C
                      </div>
                    </div>
                  )}
                </div>
              ))}
              <div ref={chatEndRef} />
            </div>

            {/* Input */}
            <div className="flex gap-2">
              <Input
                placeholder="H·ªèi t√¥i v·ªÅ doanh thu, team performance, KPI, ho·∫∑c b·∫•t c·ª© g√¨..."
                value={inputMessage}
                onChange={(e) => setInputMessage(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && handleSendMessage()}
                disabled={sendMessageMutation.isPending}
              />
              <Button
                onClick={handleSendMessage}
                disabled={sendMessageMutation.isPending || !inputMessage.trim()}
              >
                {sendMessageMutation.isPending ? (
                  <RefreshCw className="h-4 w-4 animate-spin" />
                ) : (
                  <Send className="h-4 w-4" />
                )}
              </Button>
            </div>

            {/* Quick Suggestions */}
            <div className="flex flex-wrap gap-2 mt-3">
              {[
                'T√¨nh h√¨nh doanh thu th·∫ø n√†o?',
                'Team perform ra sao?',
                'C√≥ task n√†o qu√° h·∫°n?',
                'ƒê·ªÅ xu·∫•t action cho tu·∫ßn n√†y',
              ].map((suggestion) => (
                <Button
                  key={suggestion}
                  variant="outline"
                  size="sm"
                  className="text-xs"
                  onClick={() => {
                    setInputMessage(suggestion);
                    setTimeout(() => handleSendMessage(), 100);
                  }}
                  disabled={sendMessageMutation.isPending}
                >
                  {suggestion}
                </Button>
              ))}
            </div>
          </CardContent>
        </Card>
      </div>
    </TabsContent>

    <TabsContent value="delegator" className="mt-6">
      <TaskDelegatorContent autoDelegateData={autoDelegateData} onDataConsumed={() => setAutoDelegateData(null)} />
    </TabsContent>
  </Tabs>
</div>
);
}

// ============================================
// EMBEDDED TASK DELEGATOR COMPONENT
// ============================================

interface ParsedTask {
  id: string;
  title: string;
  description: string;
  category: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  estimatedHours: number;
  suggestedEmployee: {
    id: string;
    name: string;
    role: string;
    currentWorkload: number;
    matchScore: number;
    reason: string;
  } | null;
  instructions: string[];
  dueDate: string;
  status: 'pending' | 'approved' | 'rejected';
}

interface Employee {
  id: string;
  full_name: string;
  role: string;
  currentTasks: number;
}

interface TaskDelegatorContentProps {
  autoDelegateData?: { autoGenerated: string; businessContext: any } | null;
  onDataConsumed?: () => void;
}

function TaskDelegatorContent({ autoDelegateData, onDataConsumed }: TaskDelegatorContentProps) {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [rawInput, setRawInput] = useState('');
  const [parsedTasks, setParsedTasks] = useState<ParsedTask[]>([]);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  // Auto-fill from AI Assistant's auto-delegate feature
  useEffect(() => {
    if (autoDelegateData?.autoGenerated) {
      console.log('üéØ Auto-Delegate: Received AI-generated tasks', {
        length: autoDelegateData.autoGenerated.length,
        context: autoDelegateData.businessContext
      });

      setRawInput(autoDelegateData.autoGenerated);
      onDataConsumed?.(); // Clear the data after consuming

      toast({
        title: 'ü§ñ AI Auto-Delegate Activated',
        description: `AI ƒë√£ ph√¢n t√≠ch t√¨nh h√¨nh doanh nghi·ªáp v√† ƒë·ªÅ xu·∫•t tasks c·∫ßn giao ngay.`,
        duration: 5000,
      });
    }
  }, [autoDelegateData]);

  // Fetch employees for assignment
  const { data: employees } = useQuery<Employee[]>({
    queryKey: ['employees-for-delegation'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data: company } = await supabase
        .from('companies')
        .select('id')
        .eq('owner_id', user.id)
        .single();

      if (!company) throw new Error('Company not found');

      const { data: employeesList } = await supabase
        .from('employees')
        .select('id, full_name, role')
        .eq('company_id', company.id)
        .eq('is_active', true)
        .is('deleted_at', null);

      const employeesWithWorkload = await Promise.all(
        (employeesList || []).map(async (emp) => {
          const { count } = await supabase
            .from('tasks')
            .select('*', { count: 'exact', head: true })
            .eq('assigned_to', emp.id)
            .neq('status', 'completed')
            .is('deleted_at', null);

          return { ...emp, currentTasks: count || 0 };
        })
      );

      return employeesWithWorkload;
    },
  });

  const analyzeTasks = async () => {
    if (!rawInput.trim()) {
      toast({ title: 'Vui l√≤ng nh·∫≠p danh s√°ch c√¥ng vi·ªác', variant: 'destructive' });
      return;
    }

    setIsAnalyzing(true);

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const prompt = `You are an AI Task Manager for a CEO. Parse this natural language task list and create structured tasks.

TASK LIST:
${rawInput}

AVAILABLE EMPLOYEES:
${employees?.map(e => `- ${e.full_name} (${e.role}): Currently has ${e.currentTasks} active tasks`).join('\n')}

RETURN JSON ARRAY with this structure for EACH task:
[
  {
    "title": "Clear, actionable task title (Vietnamese)",
    "description": "Detailed description (Vietnamese)",
    "category": "marketing|operations|admin|sales|other",
    "priority": "low|medium|high",
    "estimatedHours": number,
    "suggestedEmployeeId": "employee_id or null",
    "matchReason": "Why this employee is best fit (Vietnamese)",
    "matchScore": 0-100,
    "instructions": ["Step 1", "Step 2", "Step 3"],
    "dueDate": "YYYY-MM-DD"
  }
]

RULES:
1. Parse Vietnamese naturally
2. Break down vague tasks into specific actionable items
3. Suggest employee based on role + current workload
4. Add clear step-by-step instructions
5. Estimate realistic hours
6. Smart due dates (daily = today, weekly = end of week)
7. If no suitable employee, suggestedEmployeeId = null
8. Use "high" priority for urgent tasks

RETURN ONLY THE JSON ARRAY, NO MARKDOWN, NO EXPLANATION.`;

      const response = await aiService.chat([{ role: 'user', content: prompt }]);

      let aiTasks;
      try {
        const responseContent = response.content || '';
        const cleanedContent = responseContent.replace(/```json\s*/gi, '').replace(/```\s*/g, '').trim();
        const jsonMatch = cleanedContent.match(/\[[\s\S]*\]/);
        if (jsonMatch) {
          aiTasks = JSON.parse(jsonMatch[0]);
        } else {
          aiTasks = JSON.parse(cleanedContent);
        }
      } catch (parseError) {
        console.error('Failed to parse AI response:', response);
        throw new Error('AI response kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i.');
      }

      const parsed: ParsedTask[] = aiTasks.map((task: any, index: number) => {
        const suggestedEmp = employees?.find(e => e.id === task.suggestedEmployeeId);
        return {
          id: `task-${Date.now()}-${index}`,
          title: task.title,
          description: task.description,
          category: task.category,
          priority: task.priority,
          estimatedHours: task.estimatedHours,
          suggestedEmployee: suggestedEmp ? {
            id: suggestedEmp.id,
            name: suggestedEmp.full_name,
            role: suggestedEmp.role,
            currentWorkload: suggestedEmp.currentTasks,
            matchScore: task.matchScore,
            reason: task.matchReason,
          } : null,
          instructions: task.instructions,
          dueDate: task.dueDate,
          status: 'pending' as const,
        };
      });

      setParsedTasks(parsed);
      toast({ title: '‚úÖ Ph√¢n t√≠ch th√†nh c√¥ng!', description: `AI ƒë√£ t·∫°o ${parsed.length} tasks t·ª´ input c·ªßa b·∫°n` });
    } catch (error) {
      console.error('Analysis failed:', error);
      toast({ title: 'L·ªói ph√¢n t√≠ch', description: error instanceof Error ? error.message : 'Kh√¥ng th·ªÉ ph√¢n t√≠ch tasks', variant: 'destructive' });
    } finally {
      setIsAnalyzing(false);
    }
  };

  const createTasksMutation = useMutation({
    mutationFn: async (tasksToCreate: ParsedTask[]) => {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data: company } = await supabase.from('companies').select('id').eq('owner_id', user.id).single();
      if (!company) throw new Error('Company not found');

      const tasksData = tasksToCreate.map(task => {
        const validPriority = task.priority === 'urgent' ? 'high' : task.priority;
        const assignedEmployee = task.suggestedEmployee;
        return {
          company_id: company.id,
          title: task.title,
          description: `${task.description}\n\n**üìã H∆Ø·ªöNG D·∫™N TH·ª∞C HI·ªÜN:**\n${task.instructions.map((inst, i) => `${i + 1}. ${inst}`).join('\n')}\n\n‚è±Ô∏è ∆Ø·ªõc t√≠nh: ${task.estimatedHours}h\nü§ñ AI-generated task`,
          category: task.category,
          priority: validPriority,
          status: 'pending',
          assigned_to: assignedEmployee?.id || null,
          assigned_to_name: assignedEmployee?.name || null,
          assigned_to_role: assignedEmployee?.role || null,
          due_date: task.dueDate || null,
          created_by: user.id,
        };
      });

      const { data, error } = await supabase.from('tasks').insert(tasksData).select();
      if (error) throw error;
      return data;
    },
    onSuccess: (data) => {
      toast({ title: 'üéâ Tasks ƒë√£ ƒë∆∞·ª£c t·∫°o!', description: `${data.length} tasks ƒë√£ giao cho nh√¢n vi√™n th√†nh c√¥ng` });
      setRawInput('');
      setParsedTasks([]);
      queryClient.invalidateQueries({ queryKey: ['tasks'] });
      queryClient.invalidateQueries({ queryKey: ['employees-for-delegation'] });
    },
    onError: (error) => {
      toast({ title: 'L·ªói t·∫°o tasks', description: error instanceof Error ? error.message : 'Kh√¥ng th·ªÉ t·∫°o tasks', variant: 'destructive' });
    },
  });

  const approveTask = (taskId: string) => setParsedTasks(prev => prev.map(t => t.id === taskId ? { ...t, status: 'approved' as const } : t));
  const rejectTask = (taskId: string) => setParsedTasks(prev => prev.map(t => t.id === taskId ? { ...t, status: 'rejected' as const } : t));
  const approveAll = () => setParsedTasks(prev => prev.map(t => ({ ...t, status: 'approved' as const })));

  const handleCreateTasks = () => {
    const approved = parsedTasks.filter(t => t.status === 'approved');
    if (approved.length === 0) {
      toast({ title: 'Ch∆∞a c√≥ task n√†o ƒë∆∞·ª£c approve', variant: 'destructive' });
      return;
    }
    createTasksMutation.mutate(approved);
  };

  const priorityColors = {
    low: 'bg-blue-100 text-blue-800',
    medium: 'bg-yellow-100 text-yellow-800',
    high: 'bg-orange-100 text-orange-800',
    urgent: 'bg-red-100 text-red-800',
  };

  const categoryIcons: Record<string, string> = {
    marketing: 'üì±', operations: '‚öôÔ∏è', admin: 'üìã', sales: 'üí∞', other: 'üìå',
  };

  return (
    <div className="space-y-6">
      {/* Stats */}
      <div className="grid gap-4 md:grid-cols-3">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Active Employees</p>
                <p className="text-2xl font-bold">{employees?.length || 0}</p>
              </div>
              <Users className="h-8 w-8 text-blue-500" />
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Tasks Analyzed</p>
                <p className="text-2xl font-bold">{parsedTasks.length}</p>
              </div>
              <Brain className="h-8 w-8 text-purple-500" />
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm text-muted-foreground">Ready to Create</p>
                <p className="text-2xl font-bold">{parsedTasks.filter(t => t.status === 'approved').length}</p>
              </div>
              <CheckCircle className="h-8 w-8 text-green-500" />
            </div>
          </CardContent>
        </Card>
      </div>

      <div className="grid gap-6 lg:grid-cols-2">
        {/* Input Section */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Zap className="h-5 w-5 text-yellow-500" />
              Natural Language Input
            </CardTitle>
            <CardDescription>Paste c√¥ng vi·ªác b·∫±ng ti·∫øng Vi·ªát t·ª± nhi√™n. AI s·∫Ω hi·ªÉu!</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <Textarea
              placeholder={`V√≠ d·ª•:\n\n- ƒêƒÉng 10 b√†i poster l√™n Facebook/ng√†y\n- D·ª±ng 1 video TikTok v·ªÅ s·∫£n ph·∫©m m·ªõi\n- Ki·ªÉm kho h√†ng t·ªìn kho cu·ªëi tu·∫ßn\n- B√°o c√°o doanh thu tu·∫ßn n√†y\n- G·ªçi ƒëi·ªán cho 20 kh√°ch h√†ng ti·ªÅm nƒÉng`}
              value={rawInput}
              onChange={(e) => setRawInput(e.target.value)}
              className="min-h-[250px] font-mono text-sm"
              disabled={isAnalyzing}
            />
            <div className="flex gap-2">
              <Button onClick={analyzeTasks} disabled={!rawInput.trim() || isAnalyzing} className="flex-1">
                {isAnalyzing ? <><RefreshCw className="mr-2 h-4 w-4 animate-spin" />AI ƒëang ph√¢n t√≠ch...</> : <><Brain className="mr-2 h-4 w-4" />Ph√¢n T√≠ch v·ªõi AI</>}
              </Button>
              {parsedTasks.length > 0 && (
                <Button variant="outline" onClick={() => { setRawInput(''); setParsedTasks([]); }}>Reset</Button>
              )}
            </div>
          </CardContent>
        </Card>

        {/* Results Section */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Sparkles className="h-5 w-5 text-purple-500" />
              AI Analysis Results
            </CardTitle>
            <CardDescription>Review & approve tasks tr∆∞·ªõc khi giao</CardDescription>
          </CardHeader>
          <CardContent>
            {parsedTasks.length === 0 ? (
              <div className="text-center py-12 text-muted-foreground">
                <Brain className="h-12 w-12 mx-auto mb-3 opacity-50" />
                <p className="text-sm">Ch∆∞a c√≥ tasks n√†o</p>
                <p className="text-xs">Paste c√¥ng vi·ªác b√™n tr√°i v√† click "Ph√¢n T√≠ch"</p>
              </div>
            ) : (
              <div className="space-y-4">
                <div className="flex gap-2">
                  <Button size="sm" variant="outline" onClick={approveAll} className="flex-1">
                    <CheckCircle className="mr-2 h-4 w-4" />Approve All
                  </Button>
                  <Button size="sm" onClick={handleCreateTasks} disabled={parsedTasks.filter(t => t.status === 'approved').length === 0 || createTasksMutation.isPending} className="flex-1">
                    {createTasksMutation.isPending ? <RefreshCw className="mr-2 h-4 w-4 animate-spin" /> : <Send className="mr-2 h-4 w-4" />}
                    Create Tasks ({parsedTasks.filter(t => t.status === 'approved').length})
                  </Button>
                </div>
                <div className="space-y-3 max-h-[400px] overflow-y-auto">
                  {parsedTasks.map((task) => (
                    <div key={task.id} className={cn('border rounded-lg p-4 space-y-3 transition-all', task.status === 'approved' && 'border-green-500 bg-green-50', task.status === 'rejected' && 'border-red-500 bg-red-50 opacity-50')}>
                      <div className="flex items-start justify-between gap-2">
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1">
                            <span className="text-xl">{categoryIcons[task.category] || 'üìå'}</span>
                            <h4 className="font-semibold text-sm">{task.title}</h4>
                          </div>
                          <p className="text-xs text-muted-foreground">{task.description}</p>
                        </div>
                        <Badge className={cn('text-xs', priorityColors[task.priority])}>{task.priority}</Badge>
                      </div>
                      {task.suggestedEmployee && (
                        <div className="bg-blue-50 border border-blue-200 rounded p-2 text-xs">
                          <div className="flex items-center justify-between mb-1">
                            <div className="flex items-center gap-2">
                              <Users className="h-3 w-3 text-blue-600" />
                              <span className="font-semibold">{task.suggestedEmployee.name}</span>
                              <Badge variant="outline" className="text-xs">{task.suggestedEmployee.role}</Badge>
                            </div>
                            <span className="text-blue-600 font-semibold">Match: {task.suggestedEmployee.matchScore}%</span>
                          </div>
                          <p className="text-muted-foreground">{task.suggestedEmployee.reason}</p>
                        </div>
                      )}
                      <div className="flex gap-2 pt-2 border-t">
                        <Button size="sm" variant={task.status === 'approved' ? 'default' : 'outline'} onClick={() => approveTask(task.id)} disabled={task.status === 'approved'} className="flex-1">
                          <CheckCircle className="mr-1 h-3 w-3" />{task.status === 'approved' ? 'Approved' : 'Approve'}
                        </Button>
                        <Button size="sm" variant="outline" onClick={() => rejectTask(task.id)} disabled={task.status === 'rejected'} className="flex-1">
                          <AlertTriangle className="mr-1 h-3 w-3" />{task.status === 'rejected' ? 'Rejected' : 'Reject'}
                        </Button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}